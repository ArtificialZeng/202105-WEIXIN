#define _CRT_SECURE_NO_WARNINGS

#include <condition_variable>
#include <cstdio>
#include <fstream>
#include <iostream>
#include <map>
#include <mutex>
#include <string>
#include <thread>
#include <unordered_map>
#include <unordered_set>
#include <vector>

const auto 日數 = uint32_t(15);
const auto 折數 = uint32_t(8);
const auto 視訊數 = uint32_t(112873);
const auto 類目種數 = uint32_t(5);
const auto 主成分數 = uint32_t(32);
const uint32_t 類目數陣列[] = { 9, 27, 81, 243, 729, };
const auto 作者數 = uint32_t(18789);
const auto 首人工標類數 = uint32_t(354);
const auto 首機器標類數 = uint32_t(348);
const auto 用戶數 = uint32_t(250249);
const auto 最大執行緒數 = 15;

#include "基礎.h"
#include "視訊.h"
#include "行爲.h"
#include "特征.h"

auto 讀視訊資料(結構_視訊* 視訊陣列, const std::string& 路徑)
{
	std::ifstream 輸入流(路徑);
	std::string 字串;
	std::getline(輸入流, 字串);
	auto 列數 = 0;
	while (std::getline(輸入流, 字串))
	{
		列數++;
		auto&& 字串分割向量 = 分割字串(字串, ',');
		auto 視訊標識 = std::stoi(字串分割向量[0]);
		auto 作者標識 = uint16_t(std::stoi(字串分割向量[1]));
		auto 時長 = uint16_t(std::stoi(字串分割向量[2]));
		auto 配文詞數 = uint16_t(分割字串(字串分割向量[3], ' ').size());
		auto 圖片識別詞數 = uint16_t(分割字串(字串分割向量[4], ' ').size());
		auto 語音識別詞數 = uint16_t(分割字串(字串分割向量[5], ' ').size());
		auto 配文字數 = uint16_t(分割字串(字串分割向量[12], ' ').size());
		auto 圖片識別字數 = uint16_t(分割字串(字串分割向量[13], ' ').size());
		auto 語音識別字數 = uint16_t(分割字串(字串分割向量[14], ' ').size());

		auto 首人工標類 = uint16_t(首人工標類數 - 1);
		if (字串分割向量[10].size() > 0)
		{
			auto&& 人工標類字串分割向量 = 分割字串(字串分割向量[10], ';');
			首人工標類 = std::stoi(人工標類字串分割向量[0]);
		}
		auto 首機器標類 = uint16_t(首機器標類數 - 1);
		auto 首機器標類打分 = -1;
		if (字串分割向量[11].size() > 0)
		{
			auto&& 機器標類字串分割向量 = 分割字串(字串分割向量[11], ';');
			for (auto 機器標類字串 : 機器標類字串分割向量)
			{
				auto&& 機器標類字串分割向量 = 分割字串(機器標類字串, ' ');
				if (機器標類字串分割向量.size() < 2)
					continue;
				if (std::stod(機器標類字串分割向量[1]) > 首機器標類打分)
					首機器標類 = std::stoi(機器標類字串分割向量[0]);
			}
		}
		視訊陣列[視訊標識] = 結構_視訊(作者標識, 時長, 配文詞數, 圖片識別詞數, 語音識別詞數, 配文字數, 圖片識別字數, 語音識別字數, 首人工標類, 首機器標類);
	}
	輸入流.close();
	std::cout << 取得時間() << " \u5df2\u8b80\u53d6" << std::to_string(列數) << "\u5217\u8996\u8a0a\u8cc7\u6599......" << std::endl;

	return 0;
}

auto 讀類目資料(結構_視訊* 視訊陣列, const std::string& 路徑)
{
	std::ifstream 輸入流(路徑);
	std::string 字串;
	std::getline(輸入流, 字串);
	auto 列數 = 0;
	while (std::getline(輸入流, 字串))
	{
		列數++;
		auto&& 字串分割向量 = 分割字串(字串, ',');
		auto 視訊標識 = uint32_t(std::stoi(字串分割向量[0]));
		for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
			視訊陣列[視訊標識].類目陣列[甲] = uint16_t(std::stoi(字串分割向量[1 + 甲]));
	}
	輸入流.close();
	std::cout << 取得時間() << " \u5df2\u8b80\u53d6" << std::to_string(列數) << "\u5217\u8996\u8a0a\u985e\u76ee\u8cc7\u6599......" << std::endl;

	return 0;
}

auto 讀訓練資料(
	std::vector<std::shared_ptr<結構_行爲>> 日行爲指針向量陣列[1 + 日數]
	, uint32_t* 日樣本數陣列
	, uint32_t** 日視訊樣本數陣列陣列
	, uint32_t** 日作者樣本數陣列陣列
	, uint32_t** 日首人工標類樣本數陣列陣列
	, uint32_t** 日首機器標類樣本數陣列陣列
	, uint32_t** 類目種日類目樣本數陣列陣列陣列
	, std::unordered_map<std::string, uint32_t> 日交叉樣本數映射陣列[1 + 日數]
	, 結構_特征** 折視訊特征陣列陣列
	, 結構_特征** 折作者特征陣列陣列
	, 結構_特征** 折首人工標類特征陣列陣列
	, 結構_特征** 折首機器標類特征陣列陣列
	, 結構_特征** 類目種折類目特征陣列陣列陣列
	, 結構_特征** 折用戶特征陣列陣列
	, std::unordered_map<std::string, 結構_特征> 折交叉特征映射陣列[1 + 折數]
	, const std::string& 路徑
	, const 結構_視訊* 視訊陣列
)
{
	std::ifstream 輸入流(路徑);
	std::string 字串;
	std::getline(輸入流, 字串);
	while (std::getline(輸入流, 字串))
	{
		auto&& 字串分割向量 = 分割字串(字串, ',');
		auto 用戶標識 = uint32_t(std::stoi(字串分割向量[0]));
		auto 視訊標識 = uint32_t(std::stoi(字串分割向量[1]));
		auto 日期 = uint32_t(std::stoi(字串分割向量[2]));
		auto 折號 = (1 + 日期) / 2;
		auto 設備 = uint16_t(std::stoi(字串分割向量[3]));
		uint16_t 標籤陣列[7];
		標籤陣列[0] = uint16_t(std::stoi(字串分割向量[4]));
		標籤陣列[1] = uint16_t(std::stoi(字串分割向量[5]));
		標籤陣列[2] = uint16_t(std::stoi(字串分割向量[6]));
		auto 播放時長 = 0.f;
		if (字串分割向量[7].size() <= 8)
			播放時長 = 0.001f * std::stoi(字串分割向量[7]);
		auto 停留時長 = 播放時長;
		if (字串分割向量[8].size() <= 8)
			停留時長 = 0.001f * std::stoi(字串分割向量[8]);
		標籤陣列[3] = uint16_t(std::stoi(字串分割向量[9]));
		標籤陣列[4] = uint16_t(std::stoi(字串分割向量[10]));
		標籤陣列[5] = uint16_t(std::stoi(字串分割向量[11]));
		標籤陣列[6] = uint16_t(std::stoi(字串分割向量[12]));

		auto 行爲指針 = std::make_shared<結構_訓練行爲>(用戶標識, 視訊標識, 設備, 日期, 折號, 播放時長, 停留時長, 標籤陣列);
		auto& 視訊 = 視訊陣列[視訊標識];
		
		auto&& 用戶設備標識 = 取得標識(用戶標識, 行爲指針->設備);
		auto&& 用戶作者標識 = 取得標識(1, 用戶標識, 視訊.作者標識);
		auto&& 用戶首人工標類標識 = 取得標識(2, 用戶標識, 視訊.首人工標類);
		auto&& 用戶首機器標類標識 = 取得標識(3, 用戶標識, 視訊.首機器標類);
		auto&& 首人機標類標識 = 取得標識(4, 視訊.首人工標類, 視訊.首機器標類);
		auto&& 用戶作者類目4標識 = 取得標識(5, 行爲指針->用戶標識, 視訊.作者標識, 視訊.類目陣列[4]);

		日行爲指針向量陣列[日期].emplace_back(行爲指針);
		日樣本數陣列[日期] += 1;
		日視訊樣本數陣列陣列[日期][視訊標識] += 1;
		日作者樣本數陣列陣列[日期][視訊.作者標識] += 1;
		日首人工標類樣本數陣列陣列[日期][視訊.首人工標類] += 1;
		日首機器標類樣本數陣列陣列[日期][視訊.首機器標類] += 1;
		for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
			reinterpret_cast<uint32_t* (*)[1 + 日數]>(類目種日類目樣本數陣列陣列陣列)[甲][日期][視訊.類目陣列[甲]] += 1;
		auto& 交叉樣本數映射 = 日交叉樣本數映射陣列[日期];
		交叉樣本數映射[用戶設備標識] += 1;
		交叉樣本數映射[用戶作者標識] += 1;
		交叉樣本數映射[用戶首人工標類標識] += 1;
		交叉樣本數映射[用戶首機器標類標識] += 1;
		for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
		{
			auto&& 用戶甲類目標識 = 取得標識(16 + 甲, 用戶標識, 視訊.類目陣列[甲]);
			交叉樣本數映射[用戶甲類目標識] += 1;
		}

		折視訊特征陣列陣列[折號][視訊標識].新增行爲(行爲指針, 視訊.時長);
		折作者特征陣列陣列[折號][視訊.作者標識].新增行爲(行爲指針, 視訊.時長);
		折首人工標類特征陣列陣列[折號][視訊.首人工標類].新增行爲(行爲指針, 視訊.時長);
		折首機器標類特征陣列陣列[折號][視訊.首機器標類].新增行爲(行爲指針, 視訊.時長);
		for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
			reinterpret_cast<結構_特征* (*)[1 + 折數]>(類目種折類目特征陣列陣列陣列)[甲][折號][視訊.類目陣列[甲]].新增行爲(行爲指針, 視訊.時長);
		折用戶特征陣列陣列[折號][用戶標識].新增行爲(行爲指針, 視訊.時長);

		auto& 交叉特征映射 = 折交叉特征映射陣列[折號];
		交叉特征映射[用戶設備標識].新增行爲(行爲指針, 視訊.時長);
		交叉特征映射[用戶作者標識].新增行爲(行爲指針, 視訊.時長);
		交叉特征映射[用戶首人工標類標識].新增行爲(行爲指針, 視訊.時長);
		交叉特征映射[用戶首機器標類標識].新增行爲(行爲指針, 視訊.時長);
		交叉特征映射[首人機標類標識].新增行爲(行爲指針, 視訊.時長);
		交叉特征映射[用戶作者類目4標識].新增行爲(行爲指針, 視訊.時長);
		for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
		{
			auto&& 用戶甲類目標識 = 取得標識(16 + 甲, 用戶標識, 視訊.類目陣列[甲]);
			交叉特征映射[用戶甲類目標識].新增行爲(行爲指針, 視訊.時長);
		}
	}

	return 0;
}

auto 讀測試資料(
	std::vector<std::shared_ptr<結構_行爲>> 日行爲指針向量陣列[1 + 日數]
	, uint32_t* 日樣本數陣列
	, uint32_t** 日視訊樣本數陣列陣列
	, uint32_t** 日作者樣本數陣列陣列
	, uint32_t** 日首人工標類樣本數陣列陣列
	, uint32_t** 日首機器標類樣本數陣列陣列
	, uint32_t** 類目種日類目樣本數陣列陣列陣列
	, std::unordered_map<std::string, uint32_t> 日交叉樣本數映射陣列[1 + 日數]
	, 結構_特征** 折視訊特征陣列陣列
	, 結構_特征** 折作者特征陣列陣列
	, 結構_特征** 折首人工標類特征陣列陣列
	, 結構_特征** 折首機器標類特征陣列陣列
	, 結構_特征** 類目種折類目特征陣列陣列陣列
	, 結構_特征** 折用戶特征陣列陣列
	, std::unordered_map<std::string, 結構_特征> 折交叉特征映射陣列[1 + 折數]
	, const std::string& 路徑
	, const 結構_視訊* 視訊陣列
	, uint32_t 忽略標記 = 0
)
{
	std::ifstream 輸入流(路徑);
	std::string 字串;
	std::getline(輸入流, 字串);
	while (std::getline(輸入流, 字串))
	{
		auto&& 字串分割向量 = 分割字串(字串, ',');
		auto 用戶標識 = uint32_t(std::stoi(字串分割向量[0]));
		auto 視訊標識 = uint32_t(std::stoi(字串分割向量[1]));
		auto 日期 = 日數;
		auto 折號 = 折數;
		auto 設備 = uint16_t(std::stoi(字串分割向量[2]));
		auto 行爲指針 = std::make_shared<結構_測試行爲>(用戶標識, 視訊標識, 設備, 日期, 折號, 忽略標記);
		if (視訊標識 > 視訊數 - 1)
			視訊標識 = 視訊數 - 1;
		auto& 視訊 = 視訊陣列[視訊標識];

		auto&& 用戶設備標識 = 取得標識(用戶標識, 行爲指針->設備);
		auto&& 用戶作者標識 = 取得標識(1, 用戶標識, 視訊.作者標識);
		auto&& 用戶首人工標類標識 = 取得標識(2, 用戶標識, 視訊.首人工標類);
		auto&& 用戶首機器標類標識 = 取得標識(3, 用戶標識, 視訊.首機器標類);
		auto&& 首人機標類標識 = 取得標識(4, 視訊.首人工標類, 視訊.首機器標類);
		auto&& 用戶作者類目4標識 = 取得標識(5, 行爲指針->用戶標識, 視訊.作者標識, 視訊.類目陣列[4]);

		日行爲指針向量陣列[日期].emplace_back(行爲指針);
		日樣本數陣列[日期] += 1;
		日視訊樣本數陣列陣列[日期][視訊標識] += 1;
		日作者樣本數陣列陣列[日期][視訊.作者標識] += 1;
		日首人工標類樣本數陣列陣列[日期][視訊.首人工標類] += 1;
		日首機器標類樣本數陣列陣列[日期][視訊.首機器標類] += 1;
		for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
			reinterpret_cast<uint32_t* (*)[1 + 日數]>(類目種日類目樣本數陣列陣列陣列)[甲][日期][視訊.類目陣列[甲]] += 1;
		auto& 交叉樣本數映射 = 日交叉樣本數映射陣列[日期];
		交叉樣本數映射[用戶設備標識] += 1;
		交叉樣本數映射[用戶作者標識] += 1;
		交叉樣本數映射[用戶首人工標類標識] += 1;
		交叉樣本數映射[用戶首機器標類標識] += 1;
		for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
		{
			auto&& 用戶甲類目標識 = 取得標識(16 + 甲, 用戶標識, 視訊.類目陣列[甲]);
			交叉樣本數映射[用戶甲類目標識] += 1;
		}

		折視訊特征陣列陣列[折號][視訊標識].新增測試行爲(行爲指針, 視訊.時長);
		折作者特征陣列陣列[折號][視訊.作者標識].新增測試行爲(行爲指針, 視訊.時長);
		折首人工標類特征陣列陣列[折號][視訊.首人工標類].新增測試行爲(行爲指針, 視訊.時長);
		折首機器標類特征陣列陣列[折號][視訊.首機器標類].新增測試行爲(行爲指針, 視訊.時長);
		for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
			reinterpret_cast<結構_特征* (*)[1 + 折數]>(類目種折類目特征陣列陣列陣列)[甲][折號][視訊.類目陣列[甲]].新增測試行爲(行爲指針, 視訊.時長);
		折用戶特征陣列陣列[折號][用戶標識].新增測試行爲(行爲指針, 視訊.時長);

		auto& 交叉特征映射 = 折交叉特征映射陣列[折號];
		交叉特征映射[用戶設備標識].新增測試行爲(行爲指針, 視訊.時長);
		交叉特征映射[用戶作者標識].新增測試行爲(行爲指針, 視訊.時長);
		交叉特征映射[用戶首人工標類標識].新增測試行爲(行爲指針, 視訊.時長);
		交叉特征映射[用戶首機器標類標識].新增測試行爲(行爲指針, 視訊.時長);
		交叉特征映射[首人機標類標識].新增測試行爲(行爲指針, 視訊.時長);
		交叉特征映射[用戶作者類目4標識].新增測試行爲(行爲指針, 視訊.時長);
		for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
		{
			auto&& 用戶甲類目標識 = 取得標識(16 + 甲, 用戶標識, 視訊.類目陣列[甲]);
			交叉特征映射[用戶甲類目標識].新增測試行爲(行爲指針, 視訊.時長);
		}
	}

	return 0;

}

auto 取得資料(
	const std::string& 路徑
	, const 結構_視訊* 視訊陣列
	, const uint32_t 作者視訊數陣列[作者數]
	, const uint32_t 首人工標類視訊數陣列[首人工標類數]
	, const uint32_t 首機器標類視訊數陣列[首機器標類數]
	, const uint32_t** 類目種類目視訊數陣列陣列
	, const std::vector<std::shared_ptr<結構_行爲>> 日行爲指針向量陣列[1 + 日數]
	, const uint32_t 日樣本數陣列[1 + 日數]
	, const uint32_t** 日視訊樣本數陣列陣列
	, const uint32_t** 日作者樣本數陣列陣列
	, const uint32_t** 日首人工標類樣本數陣列陣列
	, const uint32_t** 日首機器標類樣本數陣列陣列
	, const uint32_t** 類目種日類目樣本數陣列陣列陣列
	, const std::unordered_map<std::string, uint32_t> 日交叉樣本數映射陣列[1 + 日數]
	, const 結構_特征** 折視訊特征陣列陣列
	, const 結構_特征** 折作者特征陣列陣列
	, const 結構_特征** 折首人工標類特征陣列陣列
	, const 結構_特征** 折首機器標類特征陣列陣列
	, const 結構_特征** 類目種折類目特征陣列陣列陣列
	, const 結構_特征** 折用戶特征陣列陣列
	, const std::unordered_map<std::string, 結構_特征> 折交叉特征映射陣列[1 + 折數]
	, const 結構_二級特征** 折視訊二級特征陣列陣列
	, const 結構_二級特征** 折用戶二級視訊特征陣列陣列
	, const 結構_二級特征** 折用戶二級作者特征陣列陣列
	, const 結構_二級特征** 折用戶二級首人工標類特征陣列陣列
	, const 結構_二級特征** 折用戶二級首機器標類特征陣列陣列
	, const 結構_二級特征** 類目種折用戶二級類目特征陣列陣列陣列
)
{
	std::shared_ptr<std::thread> 執行緒指針陣列[1 + 日數];
	auto 當前執行緒數 = 0;
	std::mutex 互斥體;
	std::condition_variable 條件變數;
	for (auto 甲 = 1U; 甲 <= 日數; 甲++)
	{
		std::unique_lock<std::mutex> 唯一鎖(互斥體);
		if (當前執行緒數 >= 最大執行緒數)
			條件變數.wait(唯一鎖);
		當前執行緒數++;
		唯一鎖.unlock();

		執行緒指針陣列[甲] = std::make_shared<std::thread>(
			[
				路徑, 甲, 視訊陣列, 作者視訊數陣列, 首人工標類視訊數陣列, 首機器標類視訊數陣列, 類目種類目視訊數陣列陣列
				, 日行爲指針向量陣列, 日樣本數陣列, 日視訊樣本數陣列陣列, 日作者樣本數陣列陣列, 日首人工標類樣本數陣列陣列, 日首機器標類樣本數陣列陣列, 類目種日類目樣本數陣列陣列陣列, 日交叉樣本數映射陣列
				, 折視訊特征陣列陣列, 折作者特征陣列陣列, 折首人工標類特征陣列陣列, 折首機器標類特征陣列陣列, 類目種折類目特征陣列陣列陣列, 折用戶特征陣列陣列, 折交叉特征映射陣列
				, 折視訊二級特征陣列陣列, 折用戶二級視訊特征陣列陣列, 折用戶二級作者特征陣列陣列, 折用戶二級首人工標類特征陣列陣列, 折用戶二級首機器標類特征陣列陣列, 類目種折用戶二級類目特征陣列陣列陣列
			](
				int* 當前執行緒數指針
				, std::mutex* 互斥體指針
				, std::condition_variable* 條件變數指針
			)
				{
					auto 標識檔案 = fopen((路徑 + "_\u6a19\u8b58" + std::to_string(甲)).c_str(), "wb");
					auto 檔案 = fopen((路徑 + "_" + std::to_string(甲)).c_str(), "wb");

					std::vector<uint16_t> 資料向量;
					for (auto& 行爲指針 : 日行爲指針向量陣列[甲])
					{
						std::vector<uint32_t> 排除折向量{ 行爲指針->折號 };
						if (行爲指針->折號 != 折數)
							排除折向量.emplace_back(折數);

						if (行爲指針->用戶標識 == 1 + 用戶數 || (行爲指針->日期 == 日數 && std::dynamic_pointer_cast<結構_測試行爲>(行爲指針)->忽略標記 == 1))
							continue;

						auto 日期 = 行爲指針->日期;
						auto 視訊 = 視訊陣列[行爲指針->視訊標識];
						uint32_t 標識陣列[]{ 行爲指針->用戶標識, 行爲指針->視訊標識 };
						fwrite(標識陣列, sizeof(uint32_t), 2, 標識檔案);

						資料向量.clear();
						資料向量.emplace_back(轉半精度(float(日期)));
						行爲指針->輸出(資料向量);
						視訊.輸出(資料向量);
						資料向量.emplace_back(轉半精度(0.01f * 作者視訊數陣列[視訊.作者標識]));
						資料向量.emplace_back(轉半精度(0.01f * 首人工標類視訊數陣列[視訊.首人工標類]));
						資料向量.emplace_back(轉半精度(0.01f * 首機器標類視訊數陣列[視訊.首機器標類]));
						for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
							資料向量.emplace_back(轉半精度(0.01f * 類目種類目視訊數陣列陣列[乙][視訊.類目陣列[乙]]));

						結構_特征::輸出以陣列陣列(資料向量, 折視訊特征陣列陣列, 行爲指針->視訊標識, 排除折向量, -1, true, true, false, true);
						if (行爲指針->折號 != 折數)
							結構_二級特征::輸出以陣列陣列(資料向量, 折視訊二級特征陣列陣列, 行爲指針->視訊標識, { 行爲指針->折號 });
						else
							結構_二級特征::輸出以陣列陣列(資料向量, 折視訊二級特征陣列陣列, 行爲指針->視訊標識, { });

						結構_特征::輸出以陣列陣列(資料向量, 折作者特征陣列陣列, 視訊.作者標識, 排除折向量, -1, true, true, true, true);
						結構_特征::輸出以陣列陣列(資料向量, 折首人工標類特征陣列陣列, 視訊.首人工標類, 排除折向量);
						結構_特征::輸出以陣列陣列(資料向量, 折首機器標類特征陣列陣列, 視訊.首機器標類, 排除折向量);
						for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
						{
							auto 乙折類目特征陣列陣列 = reinterpret_cast<const 結構_特征 *(*)[1 + 折數]>(類目種折類目特征陣列陣列陣列)[乙];
							結構_特征::輸出以陣列陣列(資料向量, 乙折類目特征陣列陣列, 視訊.類目陣列[乙], 排除折向量);
						}

						結構_特征::輸出以陣列陣列(資料向量, 折用戶特征陣列陣列, 行爲指針->用戶標識, 排除折向量, -1, true, true, true, true);
						if (行爲指針->折號 != 折數)
						{
							結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級視訊特征陣列陣列, 行爲指針->用戶標識, { 行爲指針->折號 });
							結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級作者特征陣列陣列, 行爲指針->用戶標識, { 行爲指針->折號 });
							結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級首人工標類特征陣列陣列, 行爲指針->用戶標識, { 行爲指針->折號 });
							結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級首機器標類特征陣列陣列, 行爲指針->用戶標識, { 行爲指針->折號 });
							for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
								結構_二級特征::輸出以陣列陣列(資料向量, reinterpret_cast<const 結構_二級特征 *(*)[1 + 折數]>(類目種折用戶二級類目特征陣列陣列陣列)[乙], 行爲指針->用戶標識, { 行爲指針->折號 });
						}
						else
						{
							結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級視訊特征陣列陣列, 行爲指針->用戶標識, { });
							結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級作者特征陣列陣列, 行爲指針->用戶標識, { });
							結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級首人工標類特征陣列陣列, 行爲指針->用戶標識, { });
							結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級首機器標類特征陣列陣列, 行爲指針->用戶標識, { });
							for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
								結構_二級特征::輸出以陣列陣列(資料向量, reinterpret_cast<const 結構_二級特征 *(*)[1 + 折數]>(類目種折用戶二級類目特征陣列陣列陣列)[乙], 行爲指針->用戶標識, { });
						}

						auto&& 用戶設備標識 = 取得標識(行爲指針->用戶標識, 行爲指針->設備);
						結構_特征::輸出以映射指針陣列(資料向量, 折交叉特征映射陣列, 用戶設備標識, 排除折向量);

						auto&& 用戶作者標識 = 取得標識(1, 行爲指針->用戶標識, 視訊.作者標識);
						結構_特征::輸出以映射指針陣列(資料向量, 折交叉特征映射陣列, 用戶作者標識, 排除折向量);

						auto&& 用戶首人工標類標識 = 取得標識(2, 行爲指針->用戶標識, 視訊.首人工標類);
						結構_特征::輸出以映射指針陣列(資料向量, 折交叉特征映射陣列, 用戶首人工標類標識, 排除折向量);

						auto&& 用戶首機器標類標識 = 取得標識(3, 行爲指針->用戶標識, 視訊.首機器標類);
						結構_特征::輸出以映射指針陣列(資料向量, 折交叉特征映射陣列, 用戶首機器標類標識, 排除折向量);

						auto&& 首人機標類標識 = 取得標識(4, 視訊.首人工標類, 視訊.首機器標類);
						結構_特征::輸出以映射指針陣列(資料向量, 折交叉特征映射陣列, 首人機標類標識, 排除折向量);

						auto&& 用戶作者類目4標識 = 取得標識(5, 行爲指針->用戶標識, 視訊.作者標識, 視訊.類目陣列[4]);
						結構_特征::輸出以映射指針陣列(資料向量, 折交叉特征映射陣列, 用戶作者類目4標識, 排除折向量);

						for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
						{
							auto&& 用戶乙類目標識 = 取得標識(16 + 乙, 行爲指針->用戶標識, 視訊.類目陣列[乙]);
							結構_特征::輸出以映射指針陣列(資料向量, 折交叉特征映射陣列, 用戶乙類目標識, 排除折向量);
						}

						資料向量.emplace_back(轉半精度(float(日視訊樣本數陣列陣列[日期][行爲指針->視訊標識]) / 日樣本數陣列[日期]));
						資料向量.emplace_back(轉半精度(float(日作者樣本數陣列陣列[日期][視訊.作者標識]) / 日樣本數陣列[日期]));
						資料向量.emplace_back(轉半精度(float(日首人工標類樣本數陣列陣列[日期][視訊.首人工標類]) / 日樣本數陣列[日期]));
						資料向量.emplace_back(轉半精度(float(日首機器標類樣本數陣列陣列[日期][視訊.首機器標類]) / 日樣本數陣列[日期]));
						for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
							資料向量.emplace_back(轉半精度(float(reinterpret_cast<const uint32_t *(*)[1 + 日數]>(類目種日類目樣本數陣列陣列陣列)[乙][日期][視訊.類目陣列[乙]]) / 日樣本數陣列[日期]));
	
						資料向量.emplace_back(轉半精度(float(日交叉樣本數映射陣列[日期].at(用戶設備標識))));
						資料向量.emplace_back(轉半精度(float(日交叉樣本數映射陣列[日期].at(用戶作者標識))));
						資料向量.emplace_back(轉半精度(float(日交叉樣本數映射陣列[日期].at(用戶首人工標類標識))));
						資料向量.emplace_back(轉半精度(float(日交叉樣本數映射陣列[日期].at(用戶首機器標類標識))));
						for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
						{
							auto&& 用戶乙類目標識 = 取得標識(16 + 乙, 行爲指針->用戶標識, 視訊.類目陣列[乙]);
							資料向量.emplace_back(轉半精度(float(日交叉樣本數映射陣列[日期].at(用戶乙類目標識))));
						}

						fwrite(資料向量.data(), 資料向量.size(), sizeof(uint16_t), 檔案);
					}

					if (甲 == 日數)
						std::cout << 資料向量.size() << std::endl;
					fclose(檔案);
					fclose(標識檔案);

					std::stringstream 字串流;
					字串流 << 取得時間() << " \u5df2\u53d6\u5f97\u7b2c" << 甲 << "\u65e5\u8cc7\u6599......" << std::endl;
					std::cout << 字串流.str();

					std::unique_lock<std::mutex> 唯一鎖(*互斥體指針);
					(*當前執行緒數指針) -= 1;
					條件變數指針->notify_one();
					唯一鎖.unlock();
				}
		, &當前執行緒數, &互斥體, &條件變數);
	}
	for (auto 甲 = 1U; 甲 <= 日數; 甲++)
		執行緒指針陣列[甲]->join();
}

auto 匯出樣本數統計資料(
	const std::string& 路徑
	, const uint32_t 日樣本數陣列[1 + 日數]
	, const uint32_t** 日某樣本數陣列陣列
	, uint32_t 某數
)
{
	auto 測試日某樣本數比陣列 = new uint16_t[某數];
	for (auto 甲 = 0U; 甲 < 某數; 甲++)
		測試日某樣本數比陣列[甲] = 轉半精度(float(日某樣本數陣列陣列[日數][甲]) / 日樣本數陣列[日數]);
	auto 測試日某樣本數比陣列檔案 = fopen(路徑.c_str(), "wb");
	fwrite(測試日某樣本數比陣列, sizeof(uint16_t), 某數, 測試日某樣本數比陣列檔案);
	fclose(測試日某樣本數比陣列檔案);
	delete[] 測試日某樣本數比陣列;
}

auto 匯入樣本數統計資料(
	uint16_t* 測試日某樣本數比陣列
	, const std::string& 路徑
	, uint32_t 某數
)
{
	auto 測試日某樣本數比陣列檔案 = fopen(路徑.c_str(), "rb");
	fread(測試日某樣本數比陣列, sizeof(uint16_t), 某數, 測試日某樣本數比陣列檔案);
	fclose(測試日某樣本數比陣列檔案);
}

auto 匯出統計資料(
	const std::string& 路徑
	, const 結構_視訊* 視訊陣列
	, const uint32_t 作者視訊數陣列[作者數]
	, const uint32_t 首人工標類視訊數陣列[首人工標類數]
	, const uint32_t 首機器標類視訊數陣列[首機器標類數]
	, const uint32_t** 類目種類目視訊數陣列陣列
	, const uint32_t 日樣本數陣列[1 + 日數]
	, const uint32_t** 日視訊樣本數陣列陣列
	, const uint32_t** 日作者樣本數陣列陣列
	, const uint32_t** 日首人工標類樣本數陣列陣列
	, const uint32_t** 日首機器標類樣本數陣列陣列
	, const uint32_t** 類目種日類目樣本數陣列陣列陣列
	, const std::unordered_map<std::string, uint32_t>* 日交叉樣本數映射陣列
	, const 結構_特征** 折視訊特征陣列陣列
	, const 結構_特征** 折作者特征陣列陣列
	, const 結構_特征** 折首人工標類特征陣列陣列
	, const 結構_特征** 折首機器標類特征陣列陣列
	, const 結構_特征** 類目種折類目特征陣列陣列陣列
	, const 結構_特征** 折用戶特征陣列陣列
	, const std::unordered_map<std::string, 結構_特征>* 折交叉特征映射陣列
	, const 結構_二級特征** 折視訊二級特征陣列陣列
	, const 結構_二級特征** 折用戶二級視訊特征陣列陣列
	, const 結構_二級特征** 折用戶二級作者特征陣列陣列
	, const 結構_二級特征** 折用戶二級首人工標類特征陣列陣列
	, const 結構_二級特征** 折用戶二級首機器標類特征陣列陣列
	, const 結構_二級特征** 類目種折用戶二級類目特征陣列陣列陣列
)
{
	std::vector<uint32_t> 排除折向量{折數};
	std::vector<uint16_t> 資料向量;
	auto 視訊特征檔案 = fopen((路徑 + "/\u8996\u8a0a\u7279\u5f81").c_str(), "wb");
	for (auto 甲 = 0U; 甲 < 視訊數; 甲++)
	{
		資料向量.clear();

		auto& 視訊 = 視訊陣列[甲];
		視訊.輸出(資料向量);
		資料向量.emplace_back(轉半精度(0.01f * 作者視訊數陣列[視訊.作者標識]));
		資料向量.emplace_back(轉半精度(0.01f * 首人工標類視訊數陣列[視訊.首人工標類]));
		資料向量.emplace_back(轉半精度(0.01f * 首機器標類視訊數陣列[視訊.首機器標類]));
		for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
			資料向量.emplace_back(轉半精度(0.01f * 類目種類目視訊數陣列陣列[乙][視訊.類目陣列[乙]]));

		結構_特征::輸出以陣列陣列(資料向量, 折視訊特征陣列陣列, 甲, 排除折向量, -1, true, true, false, true);
		結構_二級特征::輸出以陣列陣列(資料向量, 折視訊二級特征陣列陣列,甲, { });
		結構_特征::輸出以陣列陣列(資料向量, 折作者特征陣列陣列, 視訊.作者標識, 排除折向量, -1, true, true, true, true);
		結構_特征::輸出以陣列陣列(資料向量, 折首人工標類特征陣列陣列, 視訊.首人工標類, 排除折向量);
		結構_特征::輸出以陣列陣列(資料向量, 折首機器標類特征陣列陣列, 視訊.首機器標類, 排除折向量);
		for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
		{
			auto 乙折類目特征陣列陣列 = reinterpret_cast<const 結構_特征 *(*)[1 + 折數]>(類目種折類目特征陣列陣列陣列)[乙];
			結構_特征::輸出以陣列陣列(資料向量, 乙折類目特征陣列陣列, 視訊.類目陣列[乙], 排除折向量);
		}
		fwrite(資料向量.data(), sizeof(uint16_t), 資料向量.size(), 視訊特征檔案);
	}
	fclose(視訊特征檔案);
	auto 視訊資料長度 = 資料向量.size();

	auto 用戶特征檔案 = fopen((路徑 + "/\u7528\u6236\u7279\u5f81").c_str(), "wb");
	for (auto 甲 = 0U; 甲 < 用戶數; 甲++)
	{
		資料向量.clear();

		結構_特征::輸出以陣列陣列(資料向量, 折用戶特征陣列陣列, 甲, 排除折向量, -1, true, true, true, true);
		結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級視訊特征陣列陣列, 甲, { });
		結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級作者特征陣列陣列, 甲, { });
		結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級首人工標類特征陣列陣列, 甲, { });
		結構_二級特征::輸出以陣列陣列(資料向量, 折用戶二級首機器標類特征陣列陣列, 甲, { });
		for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
			結構_二級特征::輸出以陣列陣列(資料向量, reinterpret_cast<const 結構_二級特征 *(*)[1 + 折數]>(類目種折用戶二級類目特征陣列陣列陣列)[乙], 甲, { });
		fwrite(資料向量.data(), sizeof(uint16_t), 資料向量.size(), 用戶特征檔案);
	}
	fclose(用戶特征檔案);
	auto 用戶資料長度 = 資料向量.size();


	匯出樣本數統計資料(路徑 + "/\u6e2c\u8a66\u65e5\u8996\u8a0a\u6a23\u672c\u6578\u6bd4\u9663\u5217", 日樣本數陣列, 日視訊樣本數陣列陣列, 視訊數);
	匯出樣本數統計資料(路徑 + "/\u6e2c\u8a66\u65e5\u4f5c\u8005\u6a23\u672c\u6578\u6bd4\u9663\u5217", 日樣本數陣列, 日作者樣本數陣列陣列, 作者數);
	匯出樣本數統計資料(路徑 + "/\u6e2c\u8a66\u65e5\u9996\u4eba\u5de5\u6a19\u985e\u6a23\u672c\u6578\u6bd4\u9663\u5217", 日樣本數陣列, 日首人工標類樣本數陣列陣列, 首人工標類數);
	匯出樣本數統計資料(路徑 + "/\u6e2c\u8a66\u65e5\u9996\u6a5f\u5668\u6a19\u985e\u6a23\u672c\u6578\u6bd4\u9663\u5217", 日樣本數陣列, 日首機器標類樣本數陣列陣列, 首機器標類數);

	for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
	{
		auto 日類目甲日樣本數陣列陣列 = reinterpret_cast<const uint32_t *(*)[1 + 日數]>(類目種日類目樣本數陣列陣列陣列)[甲];
		匯出樣本數統計資料(路徑 + "/\u6e2c\u8a66\u65e5\u985e\u76ee" + std::to_string(甲) + "\u6a23\u672c\u6578\u6bd4\u9663\u5217", 日樣本數陣列, 日類目甲日樣本數陣列陣列, 類目數陣列[甲]);
	}

	auto 測試日交叉樣本數映射檔案 = fopen((路徑 + "/\u6e2c\u8a66\u65e5\u4ea4\u53c9\u6a23\u672c\u6578\u6620\u5c04").c_str(), "wb");
	for (auto& 鍵值對 : 日交叉樣本數映射陣列[日數])
	{
		auto 鍵長 = 鍵值對.first.size();
		auto 鍵 = 鍵值對.first.c_str();
		auto 值 = 轉半精度(float(鍵值對.second));;
		fwrite(&鍵長, sizeof(size_t), 1, 測試日交叉樣本數映射檔案);
		fwrite(鍵, sizeof(char), 鍵長, 測試日交叉樣本數映射檔案);
		fwrite(&值, sizeof(uint16_t), 1, 測試日交叉樣本數映射檔案);
	}
	fclose(測試日交叉樣本數映射檔案);

	auto 測試折交叉特征映射檔案 = fopen((路徑 + "/\u6e2c\u8a66\u6298\u4ea4\u53c9\u7279\u5f81\u6620\u5c04").c_str(), "wb");
	for (auto& 鍵值對 : 折交叉特征映射陣列[0])
	{
		auto 鍵長 = 鍵值對.first.size();
		auto 鍵 = 鍵值對.first.c_str();

		資料向量.clear();
		結構_特征::輸出以映射指針陣列(資料向量, 折交叉特征映射陣列, 鍵值對.first, 排除折向量);
		fwrite(&鍵長, sizeof(size_t), 1, 測試折交叉特征映射檔案);
		fwrite(鍵, sizeof(char), 鍵長, 測試折交叉特征映射檔案);
		fwrite(資料向量.data(), sizeof(uint16_t), 資料向量.size(), 測試折交叉特征映射檔案);
	}
	fclose(測試折交叉特征映射檔案);
	auto 交叉特征資料長度 = 資料向量.size();

	auto 雜資料檔案 = fopen((路徑 + "/\u96dc\u8cc7\u6599").c_str(), "wb");
	uint32_t 雜資料[]{ 日樣本數陣列[日數], uint32_t(視訊資料長度), uint32_t(用戶資料長度), uint32_t(交叉特征資料長度) };
	fwrite(雜資料, sizeof(uint32_t), 4, 雜資料檔案);
	fclose(雜資料檔案);
}

int main(int 引數數量, char* 引數陣列[])
{
	std::ios_base::sync_with_stdio(false);

	std::cout << 取得時間() << " \u958b\u59cb......" << std::endl;

	auto 視訊陣列 = new 結構_視訊[視訊數]();
	讀視訊資料(視訊陣列, "../wbdc2021/data/wedata/wechat_algo_data2/feed_info.csv");
	讀類目資料(視訊陣列, "data/\u8996\u8a0a\u985e\u76ee\u88682.csv");

	auto 作者視訊數陣列 = new uint32_t[作者數]();
	auto 首人工標類視訊數陣列 = new uint32_t[首人工標類數]();
	auto 首機器標類視訊數陣列 = new uint32_t[首機器標類數]();
	uint32_t* 類目種類目視訊數陣列陣列[類目種數];
	for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
		類目種類目視訊數陣列陣列[甲] = new uint32_t[類目數陣列[甲]]();
	for (auto 甲 = 0U; 甲 < 視訊數; 甲++)
	{
		auto& 視訊 = 視訊陣列[甲];
		作者視訊數陣列[視訊.作者標識]++;
		首人工標類視訊數陣列[視訊.首人工標類]++;
		首機器標類視訊數陣列[視訊.首機器標類]++;
		for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
			類目種類目視訊數陣列陣列[乙][視訊.類目陣列[乙]]++;
	}

	std::vector<std::shared_ptr<結構_行爲>> 日行爲指針向量陣列[1 + 日數];
	uint32_t 日樣本數陣列[1 + 日數]{ 0 };
	uint32_t* 日視訊樣本數陣列陣列[1 + 日數];
	uint32_t* 日作者樣本數陣列陣列[1 + 日數];
	uint32_t* 日首人工標類樣本數陣列陣列[1 + 日數];
	uint32_t* 日首機器標類樣本數陣列陣列[1 + 日數];
	uint32_t* 類目種日類目樣本數陣列陣列陣列[類目種數][1 + 日數];
	std::unordered_map<std::string, uint32_t> 日交叉樣本數映射陣列[1 + 日數];
	for (auto 甲 = 1U; 甲 <= 日數; 甲++)
	{
		日視訊樣本數陣列陣列[甲] = new uint32_t[視訊數]();
		日作者樣本數陣列陣列[甲] = new uint32_t[作者數]();
		日首人工標類樣本數陣列陣列[甲] = new uint32_t[首人工標類數]();
		日首機器標類樣本數陣列陣列[甲] = new uint32_t[首機器標類數]();
		for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
			類目種日類目樣本數陣列陣列陣列[乙][甲] = new uint32_t[類目數陣列[乙]]();
	}

	結構_特征* 折視訊特征陣列陣列[1 + 折數];
	結構_特征* 折作者特征陣列陣列[1 + 折數];
	結構_特征* 折首人工標類特征陣列陣列[1 + 折數];
	結構_特征* 折首機器標類特征陣列陣列[1 + 折數];
	結構_特征* 類目種折類目特征陣列陣列陣列[類目種數][1 + 折數];
	結構_特征* 折用戶特征陣列陣列[1 + 折數];
	std::unordered_map<std::string, 結構_特征> 折交叉特征映射陣列[1 + 折數];
	結構_二級特征* 折視訊二級特征陣列陣列[1 + 折數];
	結構_二級特征* 折用戶二級視訊特征陣列陣列[1 + 折數];
	結構_二級特征* 折用戶二級作者特征陣列陣列[1 + 折數];
	結構_二級特征* 折用戶二級首人工標類特征陣列陣列[1 + 折數];
	結構_二級特征* 折用戶二級首機器標類特征陣列陣列[1 + 折數];
	結構_二級特征* 類目種折用戶二級類目特征陣列陣列[類目種數][1 + 折數];
	for (auto 甲 = 0U; 甲 <= 折數; 甲++)
	{
		折視訊特征陣列陣列[甲] = new 結構_特征[視訊數]();
		折作者特征陣列陣列[甲] = new 結構_特征[作者數]();
		折首人工標類特征陣列陣列[甲] = new 結構_特征[首人工標類數]();
		折首機器標類特征陣列陣列[甲] = new 結構_特征[首機器標類數]();
		for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
			類目種折類目特征陣列陣列陣列[乙][甲] = new 結構_特征[類目數陣列[乙]]();
		折用戶特征陣列陣列[甲] = new 結構_特征[用戶數]();
		if (甲 != 折數)
		{
			折視訊二級特征陣列陣列[甲] = new 結構_二級特征[視訊數]();
			折用戶二級視訊特征陣列陣列[甲] = new 結構_二級特征[用戶數]();
			折用戶二級作者特征陣列陣列[甲] = new 結構_二級特征[用戶數]();
			折用戶二級首人工標類特征陣列陣列[甲] = new 結構_二級特征[用戶數]();
			折用戶二級首機器標類特征陣列陣列[甲] = new 結構_二級特征[用戶數]();
			for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
				類目種折用戶二級類目特征陣列陣列[乙][甲] = new 結構_二級特征[用戶數]();
		}
	}

	for (auto 甲 : {"../wbdc2021/data/wedata/wechat_algo_data1/user_action.csv" , "../wbdc2021/data/wedata/wechat_algo_data2/user_action.csv"})
	{
		讀訓練資料(
			日行爲指針向量陣列
			, 日樣本數陣列
			, 日視訊樣本數陣列陣列
			, 日作者樣本數陣列陣列
			, 日首人工標類樣本數陣列陣列
			, 日首機器標類樣本數陣列陣列
			, reinterpret_cast<uint32_t**>(類目種日類目樣本數陣列陣列陣列)
			, 日交叉樣本數映射陣列
			, 折視訊特征陣列陣列
			, 折作者特征陣列陣列
			, 折首人工標類特征陣列陣列
			, 折首機器標類特征陣列陣列
			, reinterpret_cast<結構_特征**>(類目種折類目特征陣列陣列陣列)
			, 折用戶特征陣列陣列
			, 折交叉特征映射陣列
			, 甲
			, 視訊陣列
		);
	}
	
	for (auto 甲 : { "../wbdc2021/data/wedata/wechat_algo_data1/test_a.csv", "../wbdc2021/data/wedata/wechat_algo_data1/test_b.csv" })
	{
		讀測試資料(
			日行爲指針向量陣列
			, 日樣本數陣列
			, 日視訊樣本數陣列陣列
			, 日作者樣本數陣列陣列
			, 日首人工標類樣本數陣列陣列
			, 日首機器標類樣本數陣列陣列
			, reinterpret_cast<uint32_t**>(類目種日類目樣本數陣列陣列陣列)
			, 日交叉樣本數映射陣列
			, 折視訊特征陣列陣列
			, 折作者特征陣列陣列
			, 折首人工標類特征陣列陣列
			, 折首機器標類特征陣列陣列
			, reinterpret_cast<結構_特征**>(類目種折類目特征陣列陣列陣列)
			, 折用戶特征陣列陣列
			, 折交叉特征映射陣列
			, 甲
			, 視訊陣列
			, 1
		);
	}

	std::cout << 取得時間() << " \u5df2\u8b80\u53d6\u8a13\u7df4\u8cc7\u6599......" << std::endl;

	讀測試資料(
		日行爲指針向量陣列
		, 日樣本數陣列
		, 日視訊樣本數陣列陣列
		, 日作者樣本數陣列陣列
		, 日首人工標類樣本數陣列陣列
		, 日首機器標類樣本數陣列陣列
		, reinterpret_cast<uint32_t**>(類目種日類目樣本數陣列陣列陣列)
		, 日交叉樣本數映射陣列
		, 折視訊特征陣列陣列
		, 折作者特征陣列陣列
		, 折首人工標類特征陣列陣列
		, 折首機器標類特征陣列陣列
		, reinterpret_cast<結構_特征**>(類目種折類目特征陣列陣列陣列)
		, 折用戶特征陣列陣列
		, 折交叉特征映射陣列
		, "../wbdc2021/data/wedata/wechat_algo_data2/test_a.csv"
		, 視訊陣列
	);

	for (auto 甲 = 1U; 甲 < 日數; 甲++)
	{
		for (auto 行爲指針 : 日行爲指針向量陣列[甲])
		{
			auto 用戶設備標識 = 取得標識(行爲指針->用戶標識, 行爲指針->設備);
			auto 視訊 = 視訊陣列[行爲指針->視訊標識];
			折視訊二級特征陣列陣列[行爲指針->折號][行爲指針->視訊標識].新增特征(std::static_pointer_cast<結構_訓練行爲>(行爲指針), 折交叉特征映射陣列[行爲指針->折號].at(用戶設備標識));
			折用戶二級視訊特征陣列陣列[行爲指針->折號][行爲指針->用戶標識].新增特征(std::static_pointer_cast<結構_訓練行爲>(行爲指針), 折視訊特征陣列陣列[行爲指針->折號][行爲指針->視訊標識]);
			折用戶二級作者特征陣列陣列[行爲指針->折號][行爲指針->用戶標識].新增特征(std::static_pointer_cast<結構_訓練行爲>(行爲指針), 折作者特征陣列陣列[行爲指針->折號][視訊.作者標識]);
			折用戶二級首人工標類特征陣列陣列[行爲指針->折號][行爲指針->用戶標識].新增特征(std::static_pointer_cast<結構_訓練行爲>(行爲指針), 折首人工標類特征陣列陣列[行爲指針->折號][視訊.首人工標類]);
			折用戶二級首機器標類特征陣列陣列[行爲指針->折號][行爲指針->用戶標識].新增特征(std::static_pointer_cast<結構_訓練行爲>(行爲指針), 折首機器標類特征陣列陣列[行爲指針->折號][視訊.首機器標類]);
			for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
				類目種折用戶二級類目特征陣列陣列[乙][行爲指針->折號][行爲指針->用戶標識].新增特征(std::static_pointer_cast<結構_訓練行爲>(行爲指針), 類目種折類目特征陣列陣列陣列[乙][行爲指針->折號][視訊.類目陣列[乙]]);
		}
	}

	for (auto 甲 = 1U; 甲 < 1 + 折數; 甲++)
	{
		for (auto 乙 = 0U; 乙 < 視訊數; 乙++)
			折視訊特征陣列陣列[0][乙].合併(折視訊特征陣列陣列[甲][乙]);
		for (auto 乙 = 0U; 乙 < 作者數; 乙++)
			折作者特征陣列陣列[0][乙].合併(折作者特征陣列陣列[甲][乙]);
		for (auto 乙 = 0U; 乙 < 首人工標類數; 乙++)
			折首人工標類特征陣列陣列[0][乙].合併(折首人工標類特征陣列陣列[甲][乙]);
		for (auto 乙 = 0U; 乙 < 首機器標類數; 乙++)
			折首機器標類特征陣列陣列[0][乙].合併(折首機器標類特征陣列陣列[甲][乙]);
		for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
			for (auto 丙 = 0U; 丙 < 類目數陣列[乙]; 丙++)
				類目種折類目特征陣列陣列陣列[乙][0][丙].合併(類目種折類目特征陣列陣列陣列[乙][甲][丙]);
		for (auto 乙 = 0U; 乙 < 用戶數; 乙++)
			折用戶特征陣列陣列[0][乙].合併(折用戶特征陣列陣列[甲][乙]);

		for (auto& 鍵值對 : 折交叉特征映射陣列[甲])
			折交叉特征映射陣列[0][鍵值對.first].合併(鍵值對.second);

		if (甲 != 折數)
		{
			for (auto 乙 = 0U; 乙 < 視訊數; 乙++)
				折視訊二級特征陣列陣列[0][乙].合併(折視訊二級特征陣列陣列[甲][乙]);
			for (auto 乙 = 0U; 乙 < 用戶數; 乙++)
			{
				折用戶二級視訊特征陣列陣列[0][乙].合併(折用戶二級視訊特征陣列陣列[甲][乙]);
				折用戶二級作者特征陣列陣列[0][乙].合併(折用戶二級視訊特征陣列陣列[甲][乙]);
				折用戶二級首人工標類特征陣列陣列[0][乙].合併(折用戶二級視訊特征陣列陣列[甲][乙]);
				折用戶二級首機器標類特征陣列陣列[0][乙].合併(折用戶二級視訊特征陣列陣列[甲][乙]);
				for (auto 丙 = 0U; 丙 < 類目種數; 丙++)
					類目種折用戶二級類目特征陣列陣列[丙][0][乙].合併(類目種折用戶二級類目特征陣列陣列[丙][甲][乙]);
			}
		}
	}

	取得資料(
		"data/\u8cc7\u6599"
		, 視訊陣列
		, 作者視訊數陣列
		, 首人工標類視訊數陣列
		, 首機器標類視訊數陣列
		, const_cast<const uint32_t**>(類目種類目視訊數陣列陣列)
		, 日行爲指針向量陣列
		, 日樣本數陣列
		, const_cast<const uint32_t**>(日視訊樣本數陣列陣列)
		, const_cast<const uint32_t**>(日作者樣本數陣列陣列)
		, const_cast<const uint32_t**>(日首人工標類樣本數陣列陣列)
		, const_cast<const uint32_t**>(日首機器標類樣本數陣列陣列)
		, const_cast<const uint32_t**>(reinterpret_cast<uint32_t**>(類目種日類目樣本數陣列陣列陣列))
		, 日交叉樣本數映射陣列
		, const_cast<const 結構_特征**>(折視訊特征陣列陣列)
		, const_cast<const 結構_特征**>(折作者特征陣列陣列)
		, const_cast<const 結構_特征**>(折首人工標類特征陣列陣列)
		, const_cast<const 結構_特征**>(折首機器標類特征陣列陣列)
		, const_cast<const 結構_特征**>(reinterpret_cast<結構_特征**>(類目種折類目特征陣列陣列陣列))
		, const_cast<const 結構_特征**>(折用戶特征陣列陣列)
		, 折交叉特征映射陣列
		, const_cast<const 結構_二級特征**>(折視訊二級特征陣列陣列)
		, const_cast<const 結構_二級特征**>(折用戶二級視訊特征陣列陣列)
		, const_cast<const 結構_二級特征**>(折用戶二級作者特征陣列陣列)
		, const_cast<const 結構_二級特征**>(折用戶二級首人工標類特征陣列陣列)
		, const_cast<const 結構_二級特征**>(折用戶二級首機器標類特征陣列陣列)
		, const_cast<const 結構_二級特征**>(reinterpret_cast<結構_二級特征**>(類目種折用戶二級類目特征陣列陣列))
	);

	std::cout << 取得時間() << " \u5df2\u53d6\u5f97\u8cc7\u6599......" << std::endl;


	匯出統計資料(
		"data"
		, 視訊陣列
		, 作者視訊數陣列
		, 首人工標類視訊數陣列
		, 首機器標類視訊數陣列
		, const_cast<const uint32_t**>(類目種類目視訊數陣列陣列)
		, 日樣本數陣列
		, const_cast<const uint32_t**>(日視訊樣本數陣列陣列)
		, const_cast<const uint32_t**>(日作者樣本數陣列陣列)
		, const_cast<const uint32_t**>(日首人工標類樣本數陣列陣列)
		, const_cast<const uint32_t**>(日首機器標類樣本數陣列陣列)
		, const_cast<const uint32_t**>(reinterpret_cast<uint32_t**>(類目種日類目樣本數陣列陣列陣列))
		, 日交叉樣本數映射陣列
		, const_cast<const 結構_特征**>(折視訊特征陣列陣列)
		, const_cast<const 結構_特征**>(折作者特征陣列陣列)
		, const_cast<const 結構_特征**>(折首人工標類特征陣列陣列)
		, const_cast<const 結構_特征**>(折首機器標類特征陣列陣列)
		, const_cast<const 結構_特征**>(reinterpret_cast<結構_特征**>(類目種折類目特征陣列陣列陣列))
		, const_cast<const 結構_特征**>(折用戶特征陣列陣列)
		, 折交叉特征映射陣列
		, const_cast<const 結構_二級特征**>(折視訊二級特征陣列陣列)
		, const_cast<const 結構_二級特征**>(折用戶二級視訊特征陣列陣列)
		, const_cast<const 結構_二級特征**>(折用戶二級作者特征陣列陣列)
		, const_cast<const 結構_二級特征**>(折用戶二級首人工標類特征陣列陣列)
		, const_cast<const 結構_二級特征**>(折用戶二級首機器標類特征陣列陣列)
		, const_cast<const 結構_二級特征**>(reinterpret_cast<結構_二級特征**>(類目種折用戶二級類目特征陣列陣列))
	);

	std::cout << 取得時間() << " \u5df2\u532f\u51fa\u8cc7\u6599......" << std::endl;

	for (auto 甲 = 0U; 甲 <= 折數; 甲++)
	{
		if (甲 != 折數)
		{
			for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
				delete[] 類目種折用戶二級類目特征陣列陣列[乙][甲];
			delete[] 折用戶二級首機器標類特征陣列陣列[甲];
			delete[] 折用戶二級首人工標類特征陣列陣列[甲];
			delete[] 折用戶二級作者特征陣列陣列[甲];
			delete[] 折用戶二級視訊特征陣列陣列[甲];
			delete[] 折視訊二級特征陣列陣列[甲];
		}
		delete[] 折用戶特征陣列陣列[甲];
		for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
			delete[] 類目種折類目特征陣列陣列陣列[乙][甲];
		delete[] 折首機器標類特征陣列陣列[甲];
		delete[] 折首人工標類特征陣列陣列[甲];
		delete[] 折作者特征陣列陣列[甲];
		delete[] 折視訊特征陣列陣列[甲];
	}
	for (auto 甲 = 1U; 甲 < 日數; 甲++)
	{
		for (auto 乙 = 0U; 乙 < 類目種數; 乙++)
			delete[] 類目種日類目樣本數陣列陣列陣列[乙][甲];
		delete[] 日首機器標類樣本數陣列陣列[甲];
		delete[] 日首人工標類樣本數陣列陣列[甲];
		delete[] 日作者樣本數陣列陣列[甲];
		delete[] 日視訊樣本數陣列陣列[甲];
	}

	for (auto 甲 = 0U; 甲 < 類目種數; 甲++)
		delete[] 類目種類目視訊數陣列陣列[甲];
	delete[] 首機器標類視訊數陣列;
	delete[] 首人工標類視訊數陣列;
	delete[] 作者視訊數陣列;
	delete[] 視訊陣列;
	
	std::cout << 取得時間() << " \u7d50\u675f......" << std::endl;

	return 0;
}
