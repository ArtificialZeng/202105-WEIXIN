#pragma once

#include <cstdint>
#include <cmath>

#include "行爲.h"

struct 結構_特征
{
public:
	uint32_t 樣本數 = 0;
	uint32_t 設備和 = 0;
	uint32_t 標籤數陣列[7]{ 0 };
	uint32_t 視訊時長和 = 0;
	float 播放時長和 = 0;
	float 停留時長和 = 0;

	void 新增行爲(const std::shared_ptr<結構_訓練行爲> 行爲指針, uint32_t 視訊時長)
	{
		樣本數 += 1;
		設備和 += 行爲指針->設備;
		for (auto 甲 = 0; 甲 < 7; 甲++)
			標籤數陣列[甲] += 行爲指針->標籤陣列[甲];
		視訊時長和 += 視訊時長;
		播放時長和 += 行爲指針->播放時長;
		停留時長和 += 行爲指針->停留時長;
	}

	void 新增測試行爲(const std::shared_ptr<結構_測試行爲> 行爲指針, uint16_t 視訊時長)
	{
		樣本數 += 1;
		設備和 += 行爲指針->設備;
		視訊時長和 += 視訊時長;
	}

	void 合併(const 結構_特征& 特征)
	{
		樣本數 += 特征.樣本數;
		設備和 += 特征.設備和;
		for (auto 甲 = 0; 甲 < 7; 甲++)
			標籤數陣列[甲] += 特征.標籤數陣列[甲];
		視訊時長和 += 特征.視訊時長和;
		播放時長和 += 特征.播放時長和;
		停留時長和 += 特征.停留時長和;
	}

	static auto 輸出(
		std::vector<uint16_t>& 資料向量, const 結構_特征& 總特征
		, uint32_t 非當折樣本數, uint32_t 非當折標籤數陣列[], uint32_t 非當折視訊時長和, float 非當折播放時長和, float 非當折停留時長和
		, float 空值, bool 加入樣本數否, bool 加入設備平均值否, bool 加入視訊時長平均值否, bool 加入播放停留時長否)
	{
		auto 半精度空值 = 轉半精度(空值);
		if (加入樣本數否)
			資料向量.emplace_back(轉半精度(0.0001f * 總特征.樣本數));
		if (非當折樣本數 > 0)
		{
			for (auto 甲 = 0; 甲 < 7; 甲++)
				資料向量.emplace_back(轉半精度(float(非當折標籤數陣列[甲]) / 非當折樣本數));
		}
		else
		{
			for (auto 甲 = 0; 甲 < 7; 甲++)
				資料向量.emplace_back(半精度空值);
		}

		if (加入設備平均值否)
		{
			if (總特征.樣本數 > 0)
				資料向量.emplace_back(轉半精度(float(總特征.設備和) / 總特征.樣本數));
			else
				資料向量.emplace_back(半精度空值);
		}
		if (加入視訊時長平均值否)
		{
			if (總特征.樣本數 > 0)
				資料向量.emplace_back(轉半精度(float(總特征.視訊時長和) / 總特征.樣本數));
			else
				資料向量.emplace_back(半精度空值);
		}
		if (加入播放停留時長否)
		{
			if (非當折樣本數 > 0)
			{
				資料向量.emplace_back(轉半精度(非當折播放時長和 / 非當折樣本數));
				資料向量.emplace_back(轉半精度(非當折停留時長和 / 非當折樣本數));
				資料向量.emplace_back(轉半精度((非當折停留時長和 - 非當折播放時長和) / 非當折樣本數));
				資料向量.emplace_back(轉半精度(非當折播放時長和 / 非當折視訊時長和));
				資料向量.emplace_back(轉半精度(非當折停留時長和 / 非當折視訊時長和));
			}
			else
			{
				資料向量.emplace_back(半精度空值);
				資料向量.emplace_back(半精度空值);
				資料向量.emplace_back(半精度空值);
				資料向量.emplace_back(半精度空值);
				資料向量.emplace_back(半精度空值);
			}
		}
	}

	static auto 空輸出(std::vector<uint16_t>& 資料向量, bool 加入樣本數否, bool 加入設備平均值否, bool 加入視訊時長平均值否, bool 加入播放停留時長否)
	{
		auto 半精度空值 = 轉半精度(NAN);
		if (加入樣本數否)
			資料向量.emplace_back(半精度空值);
		for (auto 甲 = 0; 甲 < 7; 甲++)
			資料向量.emplace_back(半精度空值);

		if (加入設備平均值否)
			資料向量.emplace_back(半精度空值);
		if (加入視訊時長平均值否)
			資料向量.emplace_back(半精度空值);
		if (加入播放停留時長否)
		{
			資料向量.emplace_back(半精度空值);
			資料向量.emplace_back(半精度空值);
			資料向量.emplace_back(半精度空值);
			資料向量.emplace_back(半精度空值);
			資料向量.emplace_back(半精度空值);
		}
	}

	static auto 輸出以陣列陣列(std::vector<uint16_t>& 資料向量, const 結構_特征** 折特征陣列陣列, uint32_t 標識, std::vector<uint32_t> 排除折向量, float 空值 = NAN, bool 加入樣本數否 = false, bool 加入設備平均值否 = false, bool 加入視訊時長平均值否 = false, bool 加入播放停留時長否 = false)
	{
		auto&& 總特征 = 折特征陣列陣列[0][標識];
		auto 非當折樣本數 = 總特征.樣本數;
		uint32_t 非當折標籤數陣列[7];
		for (auto 甲 = 0; 甲 < 7; 甲++)
			非當折標籤數陣列[甲] = 總特征.標籤數陣列[甲];
		auto 非當折視訊時長和 = 總特征.視訊時長和;
		auto 非當折播放時長和 = 總特征.播放時長和;
		auto 非當折停留時長和 = 總特征.停留時長和;
		for (auto 甲 : 排除折向量)
		{
			auto&& 甲折特征 = 折特征陣列陣列[甲][標識];
			非當折樣本數 -= 甲折特征.樣本數;
			for (auto 乙 = 0; 乙 < 7; 乙++)
				非當折標籤數陣列[乙] -= 甲折特征.標籤數陣列[乙];
			非當折視訊時長和 -= 甲折特征.視訊時長和;
			非當折播放時長和 -= 甲折特征.播放時長和;
			非當折停留時長和 -= 甲折特征.停留時長和;
		}


		輸出(資料向量, 總特征, 非當折樣本數, 非當折標籤數陣列, 非當折視訊時長和, 非當折播放時長和, 非當折停留時長和, 空值, 加入樣本數否, 加入設備平均值否, 加入視訊時長平均值否, 加入播放停留時長否);
	}

	static auto 輸出以映射指針陣列(std::vector<uint16_t>& 資料向量, const std::unordered_map<std::string, 結構_特征> 折交叉特征映射陣列[1 + 折數], const std::string& 標識, std::vector<uint32_t> 排除折向量, float 空值 = NAN, bool 加入樣本數否 = false, bool 加入設備平均值否 = false, bool 加入視訊時長平均值否 = false, bool 加入播放停留時長否 = false)
	{
		if (折交叉特征映射陣列[0].find(標識) == 折交叉特征映射陣列[0].end())
		{
			空輸出(資料向量, 加入樣本數否, 加入設備平均值否, 加入視訊時長平均值否, 加入播放停留時長否);
			return;
		}

		auto&& 總特征 = 折交叉特征映射陣列[0].at(標識);
		auto 非當折樣本數 = 總特征.樣本數;
		uint32_t 非當折標籤數陣列[7];
		for (auto 甲 = 0; 甲 < 7; 甲++)
			非當折標籤數陣列[甲] = 總特征.標籤數陣列[甲];
		auto 非當折視訊時長和 = 總特征.視訊時長和;
		auto 非當折播放時長和 = 總特征.播放時長和;
		auto 非當折停留時長和 = 總特征.停留時長和;
		for (auto 甲 : 排除折向量)
		{
			if (折交叉特征映射陣列[甲].find(標識) == 折交叉特征映射陣列[甲].end())
				continue;

			auto&& 甲折特征 = 折交叉特征映射陣列[甲].at(標識);
			非當折樣本數 -= 甲折特征.樣本數;
			for (auto 乙 = 0; 乙 < 7; 乙++)
				非當折標籤數陣列[乙] -= 甲折特征.標籤數陣列[乙];
			非當折視訊時長和 -= 甲折特征.視訊時長和;
			非當折播放時長和 -= 甲折特征.播放時長和;
			非當折停留時長和 -= 甲折特征.停留時長和;
		}

		輸出(資料向量, 總特征, 非當折樣本數, 非當折標籤數陣列, 非當折視訊時長和, 非當折播放時長和, 非當折停留時長和, 空值, 加入樣本數否, 加入設備平均值否, 加入視訊時長平均值否, 加入播放停留時長否);
	}

	static auto 輸出以映射陣列陣列(std::vector<uint16_t>& 資料向量, const std::map<std::string, 結構_特征>* 折用戶作者類別特征映射陣列陣列[1 + 折數], int 標識, const std::string& 第二標識, std::vector<uint32_t> 排除折向量, float 空值 = NAN, bool 加入樣本數否 = false, bool 加入設備平均值否 = false, bool 加入視訊時長平均值否 = false, bool 加入播放停留時長否 = false)
	{
		if (折用戶作者類別特征映射陣列陣列[0][標識].find(第二標識) == 折用戶作者類別特征映射陣列陣列[0][標識].end())
		{
			空輸出(資料向量, 加入樣本數否, 加入設備平均值否, 加入視訊時長平均值否, 加入播放停留時長否);
			return;
		}

		auto&& 總特征 = 折用戶作者類別特征映射陣列陣列[0][標識].at(第二標識);
		auto 非當折樣本數 = 總特征.樣本數;
		uint32_t 非當折標籤數陣列[7];
		for (auto 甲 = 0; 甲 < 7; 甲++)
			非當折標籤數陣列[甲] = 總特征.標籤數陣列[甲];
		auto 非當折視訊時長和 = 總特征.視訊時長和;
		auto 非當折播放時長和 = 總特征.播放時長和;
		auto 非當折停留時長和 = 總特征.停留時長和;
		for (auto 甲 : 排除折向量)
		{
			if (折用戶作者類別特征映射陣列陣列[甲][標識].find(第二標識) == 折用戶作者類別特征映射陣列陣列[甲][標識].end())
				continue;

			auto&& 甲折特征 = 折用戶作者類別特征映射陣列陣列[甲][標識].at(第二標識);
			非當折樣本數 -= 甲折特征.樣本數;
			for (auto 乙 = 0; 乙 < 7; 乙++)
				非當折標籤數陣列[乙] -= 甲折特征.標籤數陣列[乙];
			非當折視訊時長和 -= 甲折特征.視訊時長和;
			非當折播放時長和 -= 甲折特征.播放時長和;
			非當折停留時長和 -= 甲折特征.停留時長和;
		}

		輸出(資料向量, 總特征, 非當折樣本數, 非當折標籤數陣列, 非當折視訊時長和, 非當折播放時長和, 非當折停留時長和, 空值, 加入樣本數否, 加入設備平均值否, 加入視訊時長平均值否, 加入播放停留時長否);
	}
};

struct 結構_二級特征
{
public:
	uint32_t 一級特征數 = 0;
	float 一級特征加權標籤和陣列[7]{ 0 };
	float 一級特征播放時長平均值和 = 0;
	float 一級特征停留時長平均值和 = 0;
	float 一級特征視訊時長平均值和 = 0;

	void 新增特征(const std::shared_ptr<結構_訓練行爲> 行爲指針, const 結構_特征& 用戶設備特征)
	{
		一級特征數 += 1;
		for (auto 甲 = 0; 甲 < 7; 甲++)
			一級特征加權標籤和陣列[甲] += 1 / (1 + float(pow(用戶設備特征.標籤數陣列[甲], 0.5)));
		一級特征播放時長平均值和 += 用戶設備特征.播放時長和 / 用戶設備特征.樣本數;
		一級特征停留時長平均值和 += 用戶設備特征.停留時長和 / 用戶設備特征.樣本數;
		一級特征視訊時長平均值和 += 用戶設備特征.視訊時長和 / 用戶設備特征.樣本數;
	}

	void 合併(const 結構_二級特征& 二級特征)
	{
		一級特征數 += 二級特征.一級特征數;
		for (auto 甲 = 0; 甲 < 7; 甲++)
			一級特征加權標籤和陣列[甲] += 二級特征.一級特征加權標籤和陣列[甲];
		一級特征播放時長平均值和 += 二級特征.一級特征播放時長平均值和;
		一級特征停留時長平均值和 += 二級特征.一級特征停留時長平均值和;
		一級特征視訊時長平均值和 += 二級特征.一級特征視訊時長平均值和;
	}

	static auto 輸出以陣列陣列(std::vector<uint16_t>& 資料向量, const 結構_二級特征** 折二級特征陣列陣列, uint32_t 標識, std::vector<uint32_t> 排除折向量)
	{
		auto&& 總特征 = 折二級特征陣列陣列[0][標識];
		auto 非當折一級特征數 = 總特征.一級特征數;
		float 非當折加權標籤和陣列[7];
		for (auto 甲 = 0; 甲 < 7; 甲++)
			非當折加權標籤和陣列[甲] = 總特征.一級特征加權標籤和陣列[甲];
		auto 非當折一級特征播放時長平均值 = 總特征.一級特征播放時長平均值和;
		auto 非當折一級特征停留時長平均值 = 總特征.一級特征停留時長平均值和;
		auto 非當折一級特征視訊時長平均值 = 總特征.一級特征視訊時長平均值和;
		for (auto 甲 : 排除折向量)
		{
			auto&& 甲折特征 = 折二級特征陣列陣列[甲][標識];
			非當折一級特征數 -= 甲折特征.一級特征數;
			for (auto 乙 = 0; 乙 < 7; 乙++)
				非當折加權標籤和陣列[乙] -= 甲折特征.一級特征加權標籤和陣列[乙];
			非當折一級特征播放時長平均值 -= 甲折特征.一級特征播放時長平均值和;
			非當折一級特征停留時長平均值 -= 甲折特征.一級特征停留時長平均值和;
			非當折一級特征視訊時長平均值 -= 甲折特征.一級特征視訊時長平均值和;
		}

		if (非當折一級特征數 > 0)
		{
			for (auto 甲 = 0; 甲 < 7; 甲++)
				資料向量.emplace_back(轉半精度(非當折加權標籤和陣列[甲] / 非當折一級特征數));
			資料向量.emplace_back(轉半精度(非當折一級特征播放時長平均值 / 非當折一級特征數));
			資料向量.emplace_back(轉半精度(非當折一級特征停留時長平均值 / 非當折一級特征數));
			資料向量.emplace_back(轉半精度(非當折一級特征視訊時長平均值 / 非當折一級特征數));
		}
		else
		{
			for (auto 甲 = 0; 甲 < 10; 甲++)
				資料向量.emplace_back(-1);
		}
	}
};